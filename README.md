### üë∑  ¬øQu√© queremos solucionar con arquitectura CSS

Cuando planteamos una aplicaci√≥n en cualquier lenguaje tenemos que tomar una serie de decisiones sobre su arquitectura que afectaran a la escalabilidad y mantenibilidad de la misma, y el CSS no es una excepci√≥n.

Acordar con nuestro equipo un est√°ndar de nomenclaturas de clases que comuniquen claramente la intenci√≥n de las clases va a jugar un papel muy importante en la mantenibilidad de nuestro c√≥digo. Incluso cuando usamos soluciones como CSS-in-JS o Tailwind, vamos a tener que crear componentes reutilizables, y estos necesitaran tener un nombre y recibir variables que permitan modificar ciertas propiedades, que no ser√°n muy distintas del nombre que pondr√≠amos a la clase base y sus modificadores si usamos CSS vainilla.

Adem√°s, un buen sistema de nomenclatura tambi√©n nos ayudar√° a tener selectores menos espec√≠ficos y no tener que recurrir a usar _!important_ para solucionar problemas relacionados con especificidad.

Modularizar nuestros estilos con la ayuda de un preprocesador como **SASS** tambi√©n nos ayudar√° a tener archivos peque√±os f√°ciles de localizar, entender y mantener.

Por √∫ltimo, tenemos herramientas disponibles online para detectar dead code en CSS como [Unused CSS](https://unused-css.com/), y tambi√©n herramientas que podemos incorporar en nuestro proyecto como [PurifyCSS](https://github.com/purifycss/purifycss).

### üéØ  Visualiza la calidad de tu CSS: Especificidad de los selectores

Sabemos que, en un selector, un ID es lo m√°s espec√≠fico. En segundo lugar, las clases, pseudo-clases (:hover, :active) y los selectores de atributo, como [type=text]. Por √∫ltimo, los elementos como div, article, a, etc. Esto es f√°cil de recordar, pero cuando nos encontramos selectores complejos es dif√≠cil determinar a simple vista su especificidad a simple vista. En estos casos, podemos recurrir al m√©todo de calcular la especificidad contando cuantos selectores de cada tipo hay en nuestro selector compuesto. Por ejemplo, en el caso de #header .nav a:hover, tenemos 1 id, 1 clase, 1 pseudo-clase y 1 elemento. Esto nos dar√≠a una especificidad de 1-2-1.

Esto nos va ser √∫til cuando nos encontremos con CSS a refactorizar, pero si estamos desarrollando nuestros estilos, intentaremos siempre usar selectores simples: mayoritariamente clases y anidar lo menos posible, para facilitar la lectura y comprensi√≥n de nuestros estilos. De la misma forma, lo mejor es poner los selectores menos espec√≠ficos al inicio de nuestra hoja de estilos, y los m√°s espec√≠ficos al final.

Para analizar la especificidad de nuestros selectores, podemos usar herramientas como el [Specificity Graph](https://jonassebastianohlsson.com/specificity-graph/). Lo ideal ser√° un resultado lo m√°s plano posible, y si hay subidas que se encuentren al final de nuestra hoja de estilos.

### üçÖ  Single Responsibility Principle en CSS

En CSS, como en cualquier otro lenguaje, nos interesar√° seguir patrones como el de responsabilidad √∫nica. Lo complicado ser√° determinar cu√°l es la responsabilidad de cada clase.

Si estamos tratando con clases muy gen√©ricas, como es el caso de ui-list, esa responsabilidad va a ser muy concreta y tenemos que comunicar bien cu√°l es esa responsabilidad con el nombre de la clase. En este caso suele ser mala idea mezclar atributos que hagan referencia a layout con otros que hagan referencia a theming, como colores de background, texto o dem√°s decoraciones.

En clases para elementos m√°s concretos, como podria ser header, nos podemos permitir a√±adir atributos de posici√≥n, tama√±o y theming en una misma clase ya que, como el nombre de la clase indica, la responsabilidad de esa clase es estilar el header principal de nuestra aplicaci√≥n.

### üë®‚Äçüëß‚Äçüë¶ Herencia vs Composici√≥n en CSS

A la hora de compartir partes de c√≥digo CSS nos encontramos tambi√©n con paralelismos con otros lenguajes cuando hablamos de herencia y composici√≥n.

Hay casos, como en el ejemplo de un bot√≥n con distintos themes, en los que podr√≠a tener sentido usar la herramienta @extend de Sass, que podr√≠amos considerar herencia de clases.

```
%btn {
  display: inline-block;
  padding: 0.5rem;
}

.btn-primary {
  @extend %btn;
  background: #289f5f;
  color: #fff;
}

.btn-secondary {
  @extend %btn;
  background: #333;
  color: #fff;
}

```

Usando el operador %, conseguimos que la clase base no sea incluida en el CSS generado, ya que no necesitamos usarla en ning√∫n caso. De esta forma, en el CSS final nos quedan los selectores con los atributos comunes agrupados:

```
.btn-secondary, .btn-primary {
  display: inline-block;
  padding: 0.5rem;
}

.btn-primary {
  background: #289f5f;
  color: #fff;
}

.btn-secondary {
  background: #333;
  color: #fff;
}

```

Si usamos el mismo m√©todo con clases que tienen atributos en com√∫n pero son independientes, como el caso del ejemplo de header, footer y section, estamos uniendo clases que en realidad no tienen nada que ver y a la larga podemos encontrarnos con problemas. Otra opci√≥n es usar mixins, que permiten pasar par√°metros y as√≠ tener algo m√°s de flexibilidad:

```
@mixin justify($vertical-align: center) {
  display: flex;
  justify-content: space-between;
  align-items: $vertical-align;
}

.hero {
  @include justify;
  background: #289f5f;
  color: #fff;
}

.footer {
  @include justify($vertical-align: flex-start);
  background: #333;
  color: #fff;
}

.section {
  @include justify;
  background: #fff;
  color: #333;
}

```

Los mixins pueden sernos √∫tiles, pero hay que usarlos con cuidado, para tareas muy concretas y sin abusar de demasiados par√°metros.

Realmente, la mejor opci√≥n para compartir atributos entre clases y la que deber√≠a ser nuestra opci√≥n por defecto, es componer con clases separadas:

```
.btn {
  display: inline-block;
  padding: 0.5rem;
}

.btn-primary {
  background: #289f5f;
  color: #fff;
}

.btn-secondary {
  background: #333;
  color: #fff;
}

```

As√≠, podemos usar dos clases en el mismo elemento html:

```
<a
  class="btn btn-primary"
  href="/buy">
  Comprar
</a>

```

En este caso, debemos comunicar muy bien con el nombre de las clases la relaci√≥n que existe entre ambas, y que no tendr√≠a sentido usar btn-primary por separado. Esto lo veremos en detalle en el siguiente v√≠deo.

### üß© Mejora tu CSS con BEM: ventajas e inconventes

BEM (Block, Element, Modifier) es un sistema de nomenclatura de clases que resuelve los principales problemas de escoger nombres de clases: minimiza el riesgo de colisi√≥n, reduce la necesidad de anidar selectores, y expresa de manera clara la relaci√≥n entre clases.

Lo vemos claro en este ejemplo:

```
<article class="card">
  <img class="card__img" src="/arquitectura-css.png" alt="" />
  <h3 class="card__title">Arquitectura CSS</h3>
  <strong class="card__meta">N√∫ria y Rafa</strong>
  <p>Aprende a crear layouts‚Ä¶</p>
  <button class="button button--primary">Empezar curso</button>
</article>

```

```
.card {
  &__img { }
  &__title { }
  &__meta { }
}
.button {
  &--primary { }
}

```

Tanto si miramos el HTML como el CSS, vemos claramente que card y button son independientes, que card__img, card__title y card__meta son elementos de card (ya que llevan 2 underscore), y que button--primary es un modifier de btn (ya que lleva 2 guiones).

BEM suele recibir cr√≠ticas porque las clases son muy largas y deja el html dif√≠cil de leer. Es cierto que tienden a ser m√°s largas que si no us√°ramos este sistema, pero podemos minimizar esto evitando los errores m√°s comunes.

Un error habitual es replicar la estructura que tenemos en HTML y anidar elementos dentro de otros elementos, terminando con clases como card__info__title:

```
<article class="card">
  <img class="card__img" src="/cursos/arquitectura-css.png" alt="" />
  <div class="card__info">
    <h3 class="card__info__title">Arquitectura CSS</h3>
    <strong class="card__info__meta">N√∫ria y Rafa</strong>
  </div>
  <button class="button button--primary">Empezar curso</button>
</article>

```

Esto provoca que las clases sean muy largas, pero el mayor problema es que acopla demasiado el CSS a la estructura HTML. En BEM, todos los elements deben ser elementos directos del bloque:

```
.card {
  &__info { }
  &__title { }
  &__meta { }
  &__img { }
}

```

Otro error habitual es evitar anidar hasta el punto de crear modifiers por elementos cuando tendr√≠a m√°s sentido usar un modifier de bloque:

```
<article class="card card--dark">
  <img class="card__img" src="/cursos/arquitectura-css.png" alt="" />
  <h3 class="card__title card__title--dark">Arquitectura CSS</h3>
  <strong class="card__meta card__meta--dark">N√∫ria y Rafa</strong>
</article>

```

```
.card {
  &--dark { }
  &__img { }
  &__title {
    &--dark { }
  }
  &__meta {
    &--dark { }
  }
}

```

En este caso estamos repartiendo la responsabilidad de adaptar card a un theme oscuro entre el modifier card--dark, y los modifiers de elementos card__title--dark y card__meta--dark.

En este caso est√° plenamente justificado anidar clases y hacer un solo modifier de card que se encargue tambi√©n de modificar los elementos:

```
<article class="card card--dark">
  <img class="card__img" src="/cursos/arquitectura-css.png" alt="" />
  <h3 class="card__title">Arquitectura CSS</h3>
  <strong class="card__meta">N√∫ria y Rafa</strong>
</article>

```

```
.card {
  &__img { }
  &__title { }
  &__meta { }

  &--dark {
    .card__title {}
    .card__meta {}
  }
}

```

As√≠ nos queda el HTML m√°s limpio, y en el CSS quedan las responsabilidades claramente m√°s agrupadas y es m√°s f√°cil de entender.

### ‚ö° Mejorar lo que no nos gusta de BEM con utility classes

Si aplicamos BEM de forma purista, cada vez que tuvi√©ramos que modificar un bloque o elemento tendr√≠amos que crear un modifier espec√≠fico. Pero tendremos algunos casos que se van a repetir en muchas partes de nuestra aplicaci√≥n, por ejemplo centrar un texto, poner negrita, usar un color rojo para comunicar un error‚Ä¶ Tener que crear m√∫ltiples modifiers que hagan lo mismo es tedioso y dif√≠cil de mantener, ya que si queremos cambiar algo tendremos que hacerlo en m√∫ltiples puntos de nuestra app.

Para estos casos, tiene sentido combinar BEM con utility classes:

```
<article class="card">
  <img class="card__img" src="/arquitectura-css.png" alt="" />
  <h3 class="card__title is-centered">Arquitectura CSS</h3>
  <strong class="card__meta is-centered">N√∫ria y Rafa</strong>
</article>

```

```
.card {
  &__img { }
  &__title { }
  &__meta { }
}

.is-centered {
  text-align: center;
}

```

Es importante comunicar la intenci√≥n de la utility class. Usando un prefijo como is-, nos queda claro que esta clase es una utilidad y va a modificar el elemento al que se aplique. Es importante que este tipo de clases sean muy at√≥micas, en la mayor√≠a de casos no deber√≠an contener m√°s de una propiedad. Como siempre que a√±adimos una utility class vamos a querer que se aplique esa propiedad, incluso tendr√≠a sentido a√±adir !important.

### ‚öõÔ∏è  Atomic Design: compartir lenguaje entre dise√±o y desarrollo

Atomic Design es un m√©todo para crear sistemas de dise√±o ideado por Brad Frost. Pese a estar orientado a dise√±o, podemos coger ideas que nos van a facilitar la arquitectura de nuestro CSS.

Atomic Design consiste en varios elementos:

- √Åtomos
_Son las piezas m√°s peque√±as de nuestro sistema de dise√±o. Son partes reconocibles pero indivisibles y siempre necesitar√°n de m√°s contexto para tener sentido en nuestra aplicaci√≥n. Ejemplos claros son botones, labels, t√≠tulos (elementos individuales)‚Ä¶_

- Mol√©culas
_Cuando juntamos dos o m√°s √°tomos creamos una mol√©cula. Son elementos que ya tienen un sentido por si solos, aunque no son totalmente independientes: cards, una label con un input, cpt dise√±o individual‚Ä¶_

- Organismos
_Un organismo es una composici√≥n de varias mol√©culas. Aqu√≠ si que ya estamos tratando con elementos independientes, que si sacamos de una p√°gina y los ponemos en otra seguir√°n teniendo sentido: un header, el grid/listings de cursos con sus filtros‚Ä¶_

Atomic Design tambi√©n habla de templates y p√°ginas, pero esto ya no nos afecta en el desarrollo de nuestros estilos, ya que raramente necesitaremos definir clases a nivel de p√°gina y las definiremos juntando varios organismos en nuestro HTML.

Con Atomic Design conseguimos un lenguaje ubicuo entre el equipo de dise√±o y desarrollo front-end. Eso facilitar√° mucho la comunicaci√≥n entre ambos, aunque, siendo un sistema orientado a dise√±o, se nos queda cojo cuando necesitamos definir donde poner estilos como reset o normalize, box-sizing, o a√±adir clases funcionales o de estructura.

La estructura de carpetas usando atomic design quedar√≠a as√≠:

```
styles
‚îú‚îÄ‚îÄ atoms
‚îÇ       ‚îú‚îÄ‚îÄ _button.scss
‚îÇ       ‚îú‚îÄ‚îÄ _image.scss
‚îÇ       ‚îî‚îÄ‚îÄ _pill.scss
‚îú‚îÄ‚îÄ molecules
‚îÇ       ‚îú‚îÄ‚îÄ _card.scss
‚îÇ       ‚îî‚îÄ‚îÄ _form.scss
‚îú‚îÄ‚îÄ organisms
‚îÇ       ‚îú‚îÄ‚îÄ _gallery.scss
‚îÇ       ‚îî‚îÄ‚îÄ _header.scss
‚îî‚îÄ‚îÄ index.scss

```
M√°s informaci√≥n: [Atomic Design](https://atomicdesign.bradfrost.com/table-of-contents/)

---

### üîª ITCSS: arquitectura para aplicaciones escalables

ITCSS es un sistema de arquitectura CSS ideado por Harry Roberts. IT son las iniciales de Inverted Triangle, que es lo que usamos para visualizar como vamos a organizar nuestros estilos: de lo m√°s general a lo m√°s concreto, con selectores de menos espec√≠ficos a m√°s.

### Organizaremos nuestro CSS en 7 capas:

- **Settings y Tools**
Los dos primeros niveles est√°n orientados a preprocesadores como Sass: definir variables de colores, tipograf√≠a‚Ä¶ as√≠ como mixins y funciones. Estos dos niveles no producen ning√∫n output en nuestro CSS.

- **Generic**
_En esta capa es donde pondremos estilos gen√©ricos como reset o normalize, y definici√≥n de box-sizing. Aqu√≠ ya empezamos a generar output en nuestro CSS._

- **Elements**
_Definimos los estilos de elementos HTML como h1, img, a‚Ä¶ es donde empezamos a aplicar estilos propios que cambiar√°n el aspecto de nuestra aplicaci√≥n.


- **Objects**
_En esta capa empezamos a crear clases, hasta ahora solo hemos trabajado con selectores de elemento (que tienen menos especificidad). Los objetos son clases muy reutilizables que a√±aden patrones de estructura pero sin a√±adir decoraci√≥n: clases como .container o .ui-list._


- **Components**
_Los componentes son el grueso de nuestra app. Aqu√≠ tendremos todas las clases que a√±aden estilos m√°s all√° de estructura. Al ser clases m√°s concretas, van a ser menos reutilizables: una clase main-header la vamos a aplicar menos veces que container.

- **Utilities**
_Clases de utilidad como is-error, is-centered, etc, que siempre van a sobreescribir los estilos anteriores cuando las apliquemos. Recordemos que es el caso donde podemos usar !important sin que esto haga nuestro CSS menos mantenibles._

Como vemos, con ITCSS tenemos una estructura muy clara de donde va cada tipo de estilo, aunque la carpeta components tender√° a crecer mucho. ITCSS pretende ser un sistema muy flexible y por eso deja a nuestra elecci√≥n como ordenar los componentes.

La estructura de carpetas usando ITCSS quedar√≠a as√≠:

```
styles
‚îú‚îÄ‚îÄ settings
‚îÇ       ‚îú‚îÄ‚îÄ _colors.scss
‚îÇ       ‚îî‚îÄ‚îÄ _typography.scss
‚îú‚îÄ‚îÄ tools
‚îÇ       ‚îî‚îÄ‚îÄ _mixins.scss
‚îú‚îÄ‚îÄ generic
‚îÇ       ‚îú‚îÄ‚îÄ _normalize.scss
‚îÇ       ‚îî‚îÄ‚îÄ _box-sizing.scss
‚îú‚îÄ‚îÄ elements
‚îÇ       ‚îú‚îÄ‚îÄ _headings.scss
‚îÇ       ‚îú‚îÄ‚îÄ _images.scss
‚îÇ       ‚îî‚îÄ‚îÄ _links.scss
‚îú‚îÄ‚îÄ objects
‚îÇ       ‚îú‚îÄ‚îÄ _container.scss
‚îÇ       ‚îú‚îÄ‚îÄ _grid.scss
‚îÇ       ‚îî‚îÄ‚îÄ _ui-list.scss
‚îú‚îÄ‚îÄ components
‚îÇ       ‚îú‚îÄ‚îÄ _button.scss 
‚îÇ       ‚îú‚îÄ‚îÄ _card.scss 
‚îÇ       ‚îú‚îÄ‚îÄ _forms.scss
‚îÇ       ‚îú‚îÄ‚îÄ _header.scss
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ utilities
‚îÇ       ‚îú‚îÄ‚îÄ _typography.scss 
‚îÇ       ‚îî‚îÄ‚îÄ _error.scss
‚îî‚îÄ‚îÄ index.scss

```
M√°s informaci√≥n: [ITCSS: Scalable and Maintainable CSS Architecture](https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/)

**üôå  Lo mejor de los dos mundos**

Podemos solucionar las carencias de cada sistema si los combinamos. Podemos usar la divisi√≥n de Atomic Design de √°tomos, mol√©culas y organismos para redefinir la carpeta components de ITCSS, consiguiendo as√≠ una gu√≠a clara de como organizar los componentes. Los objetos, al no tener estilos decorativos, los dejamos como nivel anterior a √°tomos.

La estructura combinando ITCSS con Atomic Design quedar√° as√≠:

```
styles
‚îú‚îÄ‚îÄ settings
‚îÇ       ‚îú‚îÄ‚îÄ _colors.scss
‚îÇ       ‚îî‚îÄ‚îÄ _typography.scss
‚îú‚îÄ‚îÄ tools
‚îÇ       ‚îî‚îÄ‚îÄ _mixins.scss
‚îú‚îÄ‚îÄ generic
‚îÇ       ‚îú‚îÄ‚îÄ _normalize.scss
‚îÇ       ‚îî‚îÄ‚îÄ _box-sizing.scss
‚îú‚îÄ‚îÄ elements
‚îÇ       ‚îú‚îÄ‚îÄ _headings.scss
‚îÇ       ‚îî‚îÄ‚îÄ _links.scss
‚îú‚îÄ‚îÄ objects
‚îÇ       ‚îú‚îÄ‚îÄ _container.scss
‚îÇ       ‚îî‚îÄ‚îÄ _ui-list.scss
‚îú‚îÄ‚îÄ atoms
‚îÇ       ‚îú‚îÄ‚îÄ _button.scss
‚îÇ       ‚îú‚îÄ‚îÄ _image.scss
‚îÇ       ‚îî‚îÄ‚îÄ _pill.scss
‚îú‚îÄ‚îÄ molecules
‚îÇ       ‚îú‚îÄ‚îÄ _card.scss
‚îÇ       ‚îî‚îÄ‚îÄ _form.scss
‚îú‚îÄ‚îÄ organisms
‚îÇ       ‚îú‚îÄ‚îÄ _gallery.scss
‚îÇ       ‚îî‚îÄ‚îÄ _header.scss
‚îú‚îÄ‚îÄ utilities
‚îÇ       ‚îú‚îÄ‚îÄ _typography.scss 
‚îÇ       ‚îî‚îÄ‚îÄ _error.scss
‚îî‚îÄ‚îÄ index.scss

```

Si nuestra aplicaci√≥n no es demasiado grande, puede ser un poco overkill tener una estructura as√≠, tenemos que valorar las necesidades de nuestros estilos y si lo vemos adecuado podemos juntar varios niveles: settings y tools, generic y elements, objetos y √°tomos‚Ä¶ Tambi√©n podemos buscar inspiraci√≥n en otros sistemas de arquitectura como [OOCSS](https://www.smashingmagazine.com/2011/12/an-introduction-to-object-oriented-css-oocss/) o [SMACSS](http://smacss.com/).

### üõ†Ô∏è  C√≥mo utilizar variables, mixins y funciones- [Ejemplo en GitHub](https://github.com/CodelyTV/css-architecture-course/tree/main/5-1-settings-and-tools)

En las capas de Settings y Tools vamos a definir las variables de nuestro preprocesador, en este caso Sass, as√≠ como mixins y funciones.

Con las variables, es interesante usar variables privadas para definir valores, y variables p√∫blicas para definir sus aplicaciones. Por ejemplo, en _colors.scss tenemos varios colores definidos en variables privadas (si no s√≥is imaginativos con los nombres de colores, pod√©is usar herramientas como [Name that color](https://chir.ag/projects/name-that-color/)):

```
$_eucalyptus: #289f5f;
$_green-pea: #19623b;
$_baltic-sea: #282729;
$_cod-gray: #181818;
$_dove-gray: #666;
$_boulder: #777;
$_white: #fff;
$_alabaster: #fafafa;
$_gallery: #ececec;

```

Estas variables privadas las usamos para definir las variables p√∫blicas:

```
$primary-color: $_eucalyptus;
$primary-dark-color: $_green-pea;

$background-dark-color: $_baltic-sea;
$background-darker-color: $_cod-gray;
$background-light-color: $_alabaster;
$background-lighter-color: $_white;

$text-color: $_cod-gray;
$text-muted-color: $_dove-gray;
$text-inverted-color: $_white;

$border-color: $_dove-gray;
$border-inverted-color: $_gallery;

```

Esto nos permite ver f√°cilmente qu√© colores se repiten y en qu√© aplicaciones, y as√≠ simplificar colores si vemos que hay tonos muy parecidos aplicados a lo mismo (siempre consultando con el departamento de dise√±o).

Es importante que las variables p√∫blicas sean por aplicaci√≥n. Por ejemplo, tenemos $background-darker-color y $text-color con el mismo valor, pero podr√≠a ser que desde dise√±o nos cambiaran el color de fondo pero no el del texto. Al ser variables independientes, ser√° mucho m√°s f√°cil hacer el cambio.

Los mixins y funciones de Sass es importante que se definan cuando vemos que sea necesario, y no definir demasiados de entrada, ya que estar√≠amos creando abstracciones prematuras.

**‚õ±Ô∏è  La base del CSS**:‚Ä®
estilos globales - [Ejemplo en GitHub](https://github.com/CodelyTV/css-architecture-course/tree/main/5-2-generic).

Cada navegador tiene sus estilos por defecto a la hora de mostrar como se muestra cada elemento. Aunque cada vez los navegadores son m√°s consistentes entre si, utilizar un reset o un normalize nos puede facilitar la creaci√≥n de estilos globales para conseguir m√°s consistencia.

Un [reset](https://meyerweb.com/eric/tools/css/reset/) va a quitar los estilos de los elementos, unific√°ndolos de tal forma que un h1 y un small van a ser del mismo tama√±o, y un strong no ser√° en negrita. Esto puede ser √∫til para asegurarnos que controlamos los estilos de todos los elementos, pero a√±ade una carga de trabajo importante y puede dejar al usuario sin contexto si nos olvidamos de estilar alg√∫n elemento.

El [normalize](https://necolas.github.io/normalize.css/), en cambio, lo que hace es normalizar los estilos entre los navegadores, pero dejando las diferencias entre elementos. As√≠, si nos olvidamos de estilar algun elemento, los estilos por defecto seguir√°n actuando y dar√°n pistas al usuario sobre lo que estan viendo. En general es m√°s recomendable usar un normalize que un reset, ya que nos libra de una carga de trabajo importante y seguiremos teniendo unos estilos base coherentes en cualquier navegador.

En esta capa tambi√©n pondremos otros estilos gen√©ricos como definir el box-sizing.

### üíÑ Empezando a aplicar estilos propios

En esta capa empezamos a definir nuestros estilos. A√∫n no escribiremos ninguna clase, sino que definimos como se mostrar√°n los elementos. Lo m√°s habitual ser√° definir estilos de tipograf√≠a y enlaces.

En este v√≠deo tambi√©n vemos la diferencia entre usar  @import  y  @use a la hora de importar archivos Sass. Cuando trabajamos con variables y mixins, es recomendable usar @use para que las variables solo sean accesibles en ese m√≥dulo de Sass, y no de forma global. As√≠ siempre vemos claramente de donde salen las variables que estamos usando, y nos queda el c√≥digo m√°s modular y f√°cil de leer y mantener. Sass esta desfavoreciendo el uso de @import y en los pr√≥ximos a√±os lo eliminar√° del lenguaje, por lo que es mejor acostumbrarnos a usar @use cuanto antes.

[Documentaci√≥n sobre @import](https://sass-lang.com/documentation/at-rules/use#configuration)

[Documentaci√≥n sobre @use](https://sass-lang.com/documentation/at-rules/use)

### ü¶† Crear objetos y √Åtomos 
- [Ejemplo en GitHub](https://github.com/CodelyTV/css-architecture-course/tree/main/6-1-objects-and-atoms).

Como hemos visto anteriormente, los objects son clases que no tienen propiedades de theme como colores, background, etc. Son clases que creamos para ayudarnos a dar estructura a nuestra aplicaci√≥n, pero seguramente no corresponden directamente a algo que nos haya pasado el departamento de dise√±o. Los √°tomos, en cambio, s√≠ que tienen propiedades visuales. Usando BEM, en estas clases podemos tener modifiers, pero no deber√≠amos encontrarnos con un objeto o √°tomo que tenga un element, ya que estamos definiendo los bloques m√°s peque√±os de nuestra aplicaci√≥n.

Cuando vemos clases de √°tomo y objeto en nuestro html, no tenemos forma de saber de qu√© tipo de clase se trata. Eso puede dificultar encontrar el archivo para ver o modificar la clase si es necesario, y tambi√©n nos dificulta la comprensi√≥n de qu√© hace cada clase. En aplicaciones grandes, nos puede interesar prefijar las clases seg√∫n su tipo, para as√≠ ver r√°pidamente que tipo de clase es:

```
objects:    o-
atoms:      a-
molecules:  m-
organisms:  g-
utilities:  u-
            is-
            has-

```

Esto puede crear clases largas y dif√≠ciles de leer, especialmente combinado con BEM, as√≠ que hay que valorar si vale la pena o no en funci√≥n del tipo de aplicaci√≥n y el equipo que tengamos.

### üß¨ Crea clases con significado: 
Mol√©culas - [Ejemplo en GitHub](https://github.com/CodelyTV/css-architecture-course/tree/main/6-2-molecules)

Las mol√©culas son un conjunto de elementos simples, para formar un componente con sentido, pero no totalmente independiente.

Puede darse el caso que ciertos elementos de la mol√©cula no se usen en ning√∫n otro sitio, por lo que podemos definirlos como partes de ella, en lugar de tener una clase de √°tomo (por ejemplo, el bot√≥n de play dentro de la mol√©cula video-thumbnail.

A este nivel, como ya nos estamos acercando al final del tri√°ngulo invertido de ITCSS, podemos empezar a anidar selectores (recordemos que los selectores deben ir de menos espec√≠ficos a m√°s).

En general debe evitarse definir propiedades como tama√±os y m√°rgenes en los estilos de una mol√©cula, ya que siempre se va a utilizar dentro de un organismo, que es el que deber√° dar la estructura que defina los tama√±os. Si ponemos por ejemplo un max-width en una mol√©cula, la estamos haciendo menos flexible y podr√≠a darse el caso que necesitemos ponerla dentro de un contexto en el que necesita ser un poco m√°s grande, forz√°ndonos a editar los estilos.

### ü¶ë Crea componentes independientes: 
Organismos - [Ejemplo en GitHub](https://github.com/CodelyTV/css-architecture-course/tree/main/6-3-organisms).

Los organismos son las clases m√°s concretas y menos reutilizables de nuestra aplicaci√≥n. Van a formar elementos que son independientes y los podemos usar en diferentes p√°ginas, pero raramente se van a repetir en la misma p√°gina. Por este motivo, en esta √∫ltima capa de nuestros componentes es muy importante evitar crear abstracciones prematuras. Al ser bloques pr√°cticamente √∫nicos, ser√° m√°s f√°cil de mantener parte de c√≥digo duplicado que mantener una abstracci√≥n incorrecta.

Tambi√©n se nos presentan preguntas interesantes si anidar selectores o bien crear clases espec√≠ficas para ello. Hay casos, como en el organismo courses, que nos va a interesar no acoplar demasiado al contenido: ahora tenemos un grid de cards, pero se podr√≠a dar el caso que en un futuro, cambi√°ramos la mol√©cula card por otra. Esto, combinado a que lo queremos estilar no tiene relaci√≥n directa con card, hace que la mejor opci√≥n sea crear una nueva clase, courses__item. En cambio, si realmente quisi√©ramos sobreescribir alguna propiedad de card (quitar el border-radius, por ejemplo), tendr√≠a sentido usar el selector .courses .card.

Por √∫ltimo, tenemos la capa final de clases de utilidad. Como hemos visto en v√≠deos anteriores, las ponemos al final pese que a su selector es relativamente poco espec√≠fico (una clase), queremos que sobreescriban cualquier clase anterior, y por esto es la √∫nica capa donde veremos el uso de !important.
